스프링 프레임워크: 등장 배경부터 스프링 부트까지스프링 프레임워크의 등장은 단순한 기술의 출현이 아니었습니다. 특정 패러다임이 생산성을 저해하는 수준에 이르렀을 때, 그에 맞서 일어난 필연적인 혁명이었습니다. 스프링의 설계 원칙을 이해하기 위해서는 그것이 해결하고자 했던 문제, 즉 스프링 이전 시대의 문제점을 살펴보아야 합니다.1. 스프링 이전의 시대: EJB의 명과 암스프링 이전, 2000년대 초반 자바 엔터프라이즈 개발은 EJB(Enterprise JavaBeans) 라는 기술이 주도하고 있었습니다. J2EE(Java 2 Platform, Enterprise Edition)와 그 핵심 기술인 EJB는 본래 복잡한 기업용 애플리케이션 개발을 단순화하려는 고귀한 목표를 가지고 있었습니다.트랜잭션 관리, 보안, 원격 객체 접근과 같은 저수준(low-level)의 복잡한 처리를 컨테이너가 대신 관리해주고, 개발자는 오직 비즈니스 로직에만 집중할 수 있도록 하겠다는 것이 그 약속의 핵심이었습니다.이론적으로 이는 개발 생산성을 획기적으로 높일 수 있는 매력적인 제안이었습니다. 그러나 EJB의 현실은 약속과 거리가 멀었고, EJB가 해결하는 문제보다 더 많은 문제들이 생겨났습니다.EJB의 문제점💣 침투적이고 복잡한 아키텍처EJB는 본질적으로 '무거운(heavyweight)' 프레임워크였습니다. 간단한 비즈니스 로직을 담는 컴포넌트 하나를 만들기 위해서도 개발자는 EJB 명세가 요구하는 여러 개의 인터페이스를 구현하고 특정 EJB 클래스를 상속해야만 했습니다. 이는 불필요한 상속 관계와 규약으로 가득 찬 상용구 코드(Boilerplate Code)의 폭발로 이어졌습니다.⛓️ 기술 침투(Technology Lock-in) 문제EJB 아키텍처의 가장 심각한 문제 중 하나는 '침투적(invasive)' 이라는 점이었습니다. 이는 프레임워크의 기술적인 요구사항이 애플리케이션의 핵심인 비즈니스 로직 코드에 깊숙이 파고드는 현상을 의미합니다. 예를 들어, 비즈니스 데이터를 담는 객체가 javax.ejb.EntityBean과 같은 EJB 전용 인터페이스를 구현해야 했습니다. 그 결과, 비즈니스 로직은 EJB라는 특정 기술에 강하게 종속(결합)되었고 기술의 변화나 발전으로부터 자유로워질 수 없었습니다.sacrificed 객체지향 원칙의 희생EJB의 가장 치명적인 결함은 자바 언어의 가장 큰 장점인 객체지향 프로그래밍(OOP)의 핵심 원칙들을 포기하게 만들었다는 점입니다. EJB의 엄격하고 경직된 상속 구조는 다형성(polymorphism)을 활용한 유연한 설계나 적절한 역할 분담을 통한 도메인 모델링을 거의 불가능하게 만들었습니다. 개발자들은 좋은 객체지향 설계 원칙을 따르는 대신, EJB라는 기술 명세에 코드를 끼워 맞춰야 했습니다.💸 저조한 성능과 높은 비용EJB의 분산 객체 모델은 극소수의 복잡한 분산 환경을 위해 설계되었지만, 이로 인한 성능 저하(ex: 원격 호출을 위한 객체 직렬화 오버헤드)는 해당 기능이 필요 없는 99%의 애플리케이션에도 부담을 주었습니다. 더불어 EJB의 모든 기능을 활용하기 위해서는 고가의 상용 웹 애플리케이션 서버(WAS)를 도입해야 했으며, 복잡한 XML 설정 파일은 고급 통합 개발 환경(IDE)의 도움 없이는 다루기 어려웠고, 이는 EJB 기반 개발의 총 소유 비용을 크게 증가시켰습니다.🐢 어려운 개발 및 테스트 사이클EJB 컴포넌트는 EJB 컨테이너 외부에서는 정상적으로 동작할 수 없었습니다. 이는 코드의 작은 변경 사항 하나를 확인하기 위해서도 '수정-빌드-서버 배포-테스트' 라는 길고 지루한 과정을 반복해야 함을 의미했습니다. 간단한 기능에 대한 자동화된 단위 테스트(Unit Test)를 작성하는 것은 거의 불가능에 가까웠습니다.이처럼 EJB의 실패는 기술 자체의 문제라기보다는, 프레임워크가 언어의 본질적 가치를 존중하지 않았을 때 어떤 문제가 발생하는지를 보여주는 철학적 실패에 가까웠습니다.기능엔터프라이즈 자바빈 (EJB)스프링 (POJO 기반)객체 모델침투적 (프레임워크 클래스 상속/구현 강제)비침투적 (순수 자바 객체, POJO)결합도높음 (비즈니스 로직이 컨테이너에 종속)낮음 (비즈니스 로직이 프레임워크로부터 독립)테스트 용이성어려움 (테스트를 위해 컨테이너 필요)쉬움 (간단한 단위 테스트 가능)복잡성높음 (상용구 코드, 복잡한 XML 설정)낮음 (반복 코드 감소, 유연한 설정)성능불필요한 기능으로 인한 오버헤드 발생경량, 필요한 기능만 선택적으로 사용2. 대안의 등장: 순수 자바 객체(POJO)로의 회귀EJB가 초래한 암흑기에 반발하며 개발자 커뮤니티에서는 새로운 대안을 모색하기 시작했습니다. 그 중심에는 기술이 아닌 자바 언어 본연의 가치로 돌아가자는 움직임이 있었고, 이 움직임은 'POJO' 라는 이름으로 구체화되었습니다.POJO (Plain Old Java Object): 말 그대로 '오래된 방식의 평범한 자바 객체'를 의미합니다. 이는 특정 프레임워크나 기술 규약에 종속되지 않은 순수한 자바 객체를 지칭하는 용어입니다.POJO는 새로운 기술이 아니라, 복잡성에 대한 저항이자 단순함으로의 회귀를 외치는 선언이었습니다.POJO 철학: 자바를 자바답게POJO의 핵심 철학은 "자바를 자바답게, OOP를 OOP답게 쓰자" 는 것입니다. 이는 특정 기술의 제약에 얽매이지 않고 자바 언어가 제공하는 객체지향의 장점(상속, 다형성, 유연한 설계)을 온전히 활용하여 애플리케이션을 개발하자는 이념입니다.POJO의 조건특정 규약에 종속되지 않아야 한다: 프레임워크가 제공하는 특정 클래스를 강제로 상속(extends)하거나 인터페이스를 구현(implements)해서는 안 된다.특정 환경에 종속되지 않아야 한다: 특정 WAS나 프레임워크 환경에서만 동작하는 코드가 되어서는 안 된다.특정 어노테이션에 종속되지 않아야 한다: (이상적으로는) 프레임워크에 특화된 어노테이션을 포함하지 않아야 한다.객체지향 원리에 충실해야 한다: 책임과 역할이 명확히 분리되고, 적절한 캡슐화와 다형성이 적용된, 잘 설계된 객체여야 한다.이러한 POJO로의 회귀 움직임에 지적인 불을 지핀 것은 개발자 로드 존슨(Rod Johnson) 이었습니다. 그는 2002년 자신의 저서 "Expert One-on-One J2EE Design and Development"를 통해 EJB의 문제점을 신랄하게 비판하고, 3만 라인이 넘는 예제 코드를 통해 EJB 없이도 고품질의 엔터프라이즈 애플리케이션을 개발할 수 있음을 증명했습니다. 이 코드가 바로 훗날 스프링 프레임워크의 모태가 되었습니다.3. 스프링의 탄생과 철학로드 존슨의 책이 출간된 후, 유겐 휠러(Juergen Hoeller)와 얀 카로프(Yann Caroff)가 그에게 오픈소스 프로젝트를 제안했습니다. 그들은 프로젝트의 이름을 '스프링(Spring)' 으로 정했는데, 이는 'EJB라는 길고 추운 겨울을 지나 새로운 봄을 맞이한다'는 상징적인 의미를 담고 있습니다.스프링(Spring)이란?"자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크"애플리케이션 프레임워크(Application Framework): 애플리케이션의 전체적인 구조와 동작 방식을 결정하는 '뼈대'를 제공합니다. 코드의 실행 흐름이 프레임워크에 의해 제어됩니다.경량급(Lightweight): EJB에 비해 상대적으로 가볍다는 의미입니다. 무겁고 비싼 WAS를 요구하지 않으며, 개발자가 작성해야 하는 코드의 복잡성을 낮춰준다는 의미에서 '가볍다'고 표현합니다.엔터프라이즈 자바(Enterprise Java): 트랜잭션, 데이터 영속성, 보안 등 대규모 기업 환경의 복잡한 요구사항을 만족시키는 강력한 솔루션을 포괄적으로 제공합니다.비침투적(Non-Invasive): POJO 철학을 계승하여, 애플리케이션의 핵심 비즈니스 객체들이 프레임워크 자체에 종속되도록 강요하지 않습니다.결론적으로 스프링의 핵심 철학은 개발자가 기술적인 '배관 작업(plumbing)'에서 벗어나 오직 애플리케이션의 비즈니스 가치를 창출하는 데 집중할 수 있도록 돕는 것입니다.4. 스프링의 핵심 기술: 스프링 삼각형 (IoC/DI, AOP, PSA)스프링이 POJO 기반의 혁신을 이룰 수 있었던 배경에는 세 가지 핵심 기술, '스프링 삼각형' 이라 불리는 IoC/DI, AOP, PSA가 있습니다.① IoC/DI (제어의 역전 / 의존성 주입)IoC/DI는 스프링 프레임워크의 근간을 이루는 가장 핵심적인 개념입니다.제어의 역전 (Inversion of Control, IoC): 객체의 생성, 생명주기 관리 등 모든 제어권이 개발자에게서 프레임워크(IoC 컨테이너)로 넘어가는 것입니다. 프레임워크가 객체를 만들고 관리하며, 필요에 따라 개발자의 코드를 호출합니다.의존성 주입 (Dependency Injection, DI): IoC를 구현하는 구체적인 프로그래밍 패턴입니다. 어떤 객체가 필요로 하는 다른 객체(의존성)를 외부(IoC 컨테이너)에서 생성하여 '주입'시켜주는 방식입니다. 이를 통해 객체들은 서로에 대해 느슨한 결합(Loose Coupling) 을 유지할 수 있습니다.코드 예시DI 적용 전 (강한 결합)public class OrderService {
    // OrderService가 KakaopayGateway 라는 구체적인 클래스에 직접 의존
    private KakaopayGateway paymentGateway = new KakaopayGateway();

    public void processOrder() {
        //...
        paymentGateway.processPayment();
        //...
    }
}
DI 적용 후 (느슨한 결합)public interface PaymentGateway {
    void processPayment();
}

@Component
public class KakaopayGateway implements PaymentGateway {
    //... 구현
}

@Service
public class OrderService {
    private final PaymentGateway paymentGateway;

    // 생성자를 통해 외부(스프링 컨테이너)에서 PaymentGateway 구현체를 주입받음
    @Autowired
    public OrderService(PaymentGateway paymentGateway) {
        this.paymentGateway = paymentGateway;
    }

    public void processOrder() {
        //...
        paymentGateway.processPayment();
        //...
    }
}
이제 OrderService는 PaymentGateway라는 '역할(인터페이스)'에만 의존합니다. 결제 수단을 바꾸고 싶을 때 OrderService의 코드를 수정할 필요가 없어집니다.② AOP (관점 지향 프로그래밍)AOP는 IoC/DI가 객체 간의 관계를 다룬다면, 객체 내부의 로직을 다루는 기술입니다.횡단 관심사 (Cross-Cutting Concerns): 로깅, 트랜잭션, 보안처럼 애플리케이션의 여러 모듈에 걸쳐 공통적으로 나타나는 부가 기능들을 의미합니다.AOP 솔루션: 이러한 횡단 관심사를 '애스펙트(Aspect)' 라는 별도의 모듈로 분리하여 관리하게 해줍니다. 핵심 비즈니스 로직은 순수하게 유지되고, 분리된 애스펙트들은 마치 외부에서 필요한 시점에 '끼워 넣는(weaving)' 것처럼 적용됩니다.스프링의 선언적 트랜잭션 관리 기능인 @Transactional 어노테이션이 AOP의 가장 대표적인 활용 사례입니다.③ PSA (이식 가능한 서비스 추상화)PSA는 스프링이 다양한 외부 기술들을 일관된 방식으로 사용할 수 있도록 지원하는 강력한 원칙입니다.문제점: 데이터베이스 접근 기술에는 JDBC, JPA, MyBatis 등 다양한 기술이 존재합니다. 만약 애플리케이션 코드가 특정 기술(예: Hibernate)의 API에 직접 의존한다면, 나중에 다른 기술로 교체할 때 모든 관련 코드를 수정해야 합니다.PSA 솔루션: 스프링은 이러한 다양한 기술들 위에 '서비스 추상화 계층' 을 제공합니다. 개발자는 스프링이 제공하는 일관된 방식의 인터페이스(@Transactional, JpaRepository 등)를 통해 기술을 사용합니다. 실제 구현 기술의 변경은 설정 파일의 변경만으로 가능해집니다.IoC/DI는 객체 생성과 의존성 해결을, AOP는 부가 기능 로직을, PSA는 특정 기술에 대한 의존성을 POJO로부터 분리합니다. 이 세 가지 기술이 합쳐져 비로소 비즈니스 로직에만 집중하는 순수한 POJO 객체를 만드는 것이 가능해집니다.5. 스프링 아키텍처와 모듈계층형 아키텍처 (Layered Architecture)스프링 애플리케이션은 대부분 각기 다른 책임을 가진 여러 개의 수평적인 계층으로 분리된 구조를 따릅니다.프레젠테이션 계층 (Presentation Layer - @Controller): 사용자와의 접점. HTTP 요청 수신 및 응답 반환. (식당의 '웨이터')비즈니스 계층 (Business Layer - @Service): 애플리케이션의 핵심 로직 구현, 트랜잭션 처리. (식당의 '주방장')데이터 접근 계층 (Persistence Layer - @Repository): 데이터베이스와의 통신(CRUD) 전담. (식당의 '재료 담당')도메인 계층 (Domain Layer - @Entity): 모든 계층에서 사용되는 핵심 데이터 모델.이 구조의 핵심 원칙은 '단방향 의존성' (프레젠테이션 → 비즈니스 → 데이터 접근)으로, 각 계층의 독립성을 보장하고 유지보수성을 높입니다.스프링 프레임워크 모듈스프링은 하나의 거대한 덩어리가 아니라, 약 20여 개의 독립적인 모듈(Module) 의 집합체입니다. 개발자는 프로젝트에 필요한 모듈만 선택적으로 사용할 수 있습니다.모듈 그룹주요 모듈핵심 기능코어 컨테이너spring-core, spring-beans, spring-contextIoC 컨테이너와 DI 등 프레임워크의 근본 기능 제공데이터 접근/통합spring-jdbc, spring-tx, spring-ormJDBC, 트랜잭션, JPA/Hibernate 등 데이터 접근 기술에 대한 PSA 제공웹spring-web, spring-webmvc, spring-websocket스프링 MVC, REST API, 웹소켓 등 웹 개발 도구 제공AOPspring-aop, spring-aspects관점 지향 프로그래밍(AOP) 기능 제공테스트spring-testJUnit, Mockito 등과 통합하여 단위 및 통합 테스트 지원6. 스프링 부트: 스프링 개발의 새로운 봄"스프링이 재료라면, 스프링 부트는 밀키트다!"스프링 부트는 스프링을 대체하는 것이 아니라, 스프링을 더 쉽고 빠르게 사용하기 위해 탄생한 프로젝트입니다. 순수 스프링 프레임워크가 가진 의존성 관리의 복잡성, 방대한 XML 설정, 외부 WAS 설정의 번거로움 등을 해결하기 위해 등장했습니다.스프링 부트의 핵심 철학은 '관례의 우선(Convention over Configuration)' 입니다."개발자가 특별히 다르게 설정하지 않는 한, 일반적이고 보편적인 방식(관례)으로 애플리케E이션을 자동 구성하겠다."스프링 부트의 핵심 기능 3가지① 자동 설정 (Auto-Configuration)스프링 부트의 심장과도 같은 기능입니다. @SpringBootApplication 어노테이션을 통해 클래스패스를 스캔하여, "이 애플리케이션은 웹 애플리케이션이구나" 또는 "JPA를 사용하는구나"라고 스스로 판단하고 필요한 빈(Bean)들을 자동으로 구성해줍니다. 개발자가 직접 DataSource나 TransactionManager 빈을 정의하면, 스프링 부트의 자동 설정은 동작하지 않아 유연한 재정의(override)가 가능합니다.② 스타터 의존성 (Starter Dependencies)복잡한 의존성 관리를 해결하기 위한 해법입니다. spring-boot-starter-web 하나만 추가하면, 스프링 MVC, 내장 톰캣, JSON 처리 라이브러리 등 웹 개발에 필요한 모든 라이브러리를 검증된 호환 버전으로 한 번에 가져옵니다. 개발자는 더 이상 '의존성 지옥(dependency hell)'을 걱정할 필요가 없습니다.③ 내장 웹 애플리케이션 서버 (Embedded WAS)스프링 부트는 기본적으로 톰캣(Tomcat) 서버를 애플리케이션 내부에 '내장'하고 있습니다. 따라서 애플리케이션은 별도의 외부 WAS 설치 없이, java -jar my-app.jar 명령어 하나로 실행 가능한 단일 JAR 파일로 패키징됩니다. 이는 개발, 테스트, 배포 과정을 극적으로 단순화하며, 도커(Docker)를 이용한 컨테이너 환경이나 마이크로서비스 아키텍처에 완벽하게 부합합니다.결국 스프링 부트는 개발자가 프레임워크 설정이라는 부차적인 작업에서 벗어나 오직 비즈니스 로직 개발이라는 본질에만 집중할 수 있도록 돕는, 스프링 생태계의 자연스러운 발전입니다.
